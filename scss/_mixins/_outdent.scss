/*
  Outdent v1
  Feb 25, 2024
*/

//	DO NOT CUT AND PASTE FROM THE CODEPEN
//	There's some Vassar-specific stuff here; namely:
/*
$small: map-get($breakpoints, 'small');
$large: map-get($breakpoints, 'large');

That's to prevent the fallback 50% width from overriding the large-screen 60% width
(it's overriding it because the fallback class is .blockquote.outdent, which is
more specific than .blockquote
*/

@mixin outdent($distance, $label, $settings: ()) {
  //  This creates a utility class that, when applied to an element,
  //  positions it a certain distance outside the left or right edge of
  //  the main content column. outdent() is best used on layouts where
  //  the main content appears in a centered column, like a story or article.

  //  At smaller window widths, the outdented element will collapse: revert to
  //  a default width, so it doesn't get too awkwardly narrow. At mobile window
  //  widths, the outdented element will have no margin or width applied, and will
  //  take up the entire width of the viewport.

  //  This can also be used to create classes for marginalia. Marginalia items
  //  are positioned completely outside the content column, set in the gutter
  //  area like a sidenote or something. The only real difference between
  //  outdented and marginalia items is that the width of a marginalia item
  //  is the same as the amount it's outdented, whereas a normal outdented item
  //  might have a width of 50% but be outdented by 10%. So if 'marginalia' is true,
  //  the generated code will have a `width: $distance` rule.

  //  The `distance` parameter needs to be in units of % or vw; no absolutes, like rem.

  //  The `label` parameter will be appended to the classname [elaborate on this]
  
  //  If `marginalia` is true, the generated utility class will position
  //  the item completely outside the content column, set in
  //  the gutter area like a sidenote or something. In this case, `distance` will
  //  also be the width of the item.

  //  Values this mixin needs:

  //  - $standard-content-width: the width of the main content area. This would
  //    be the centered column that the story/article content is in.

  //  - An array of breakpoints, arranged as follows:
  //    $breakpoints: (
  //      'sm': 30em,
  //      'md': 50em,
  //      'lg': 70em
  //    );

  //  The default settings for this mixin

  $defaults: (
	//  specify the breakpoint at which this collapses
	//  default is 'medium'
	point-of-collapse: "medium",

	//  specify the width that it collapses to
	//  default is 50%
	collapse-to: 50%,

	//  this is the breakpoint below which the item has no margin/outdentation
	//  and is full-width in the container. Default is the small breakpoint.
	below-this-is-mobile: "small",
	
	//	Marginalia items are ones that are placed entirely outside the main content,
	//  sitting in the margin (or gutter) of the story.
	
	//  If 'marginalia' is true, a width will be applied to the item. The width will be
	//  the same as the amount the item is outdented.
	marginalia: false,

	//  by default, the classes generated by this mixin will be named things
	//  like .outdent-left-24rem, or .outdent-right-8pct. But you might, as I do,
	//  want a more generic utility class that you can apply to a module. If all your
	//  blockquotes are always indented 8%, you might not want that value included in
	//  your utility class, because what if you decide at some point that blockquotes
	//  should be indented by 10% instead?
	
	//  A better way would be to have something generic like: .blockquote.outdent-right
	//  If the specific amount of outdenting changes, you're not left with a bunch of
	//  class names you need to change.
	scope-to-class: false
  );

  //  combine user-specified settings with the defaults.
  //  Any default settings not user-specified will remain.
  $settings: map-merge($defaults, $settings);

  //  To get a setting, use map-get(array, key)
  $point-of-collapse: map-get($settings, "point-of-collapse");
  $collapse-to: map-get($settings, "collapse-to");
  $below-this-is-mobile: map-get($settings, "below-this-is-mobile");
  $marginalia: map-get($settings, "marginalia");
  $scope-to-class: map-get($settings, "scope-to-class");



  //  NAMING
  //  If this is a regular outdent class - something that outdents an
  //  item by 10% or whatever - the generated class should start with
  //  'outdent'.

  //  If this is marginalia, the classname should start with 'marginalia'.

  //  Marginalia can have different widths, depending on whether they're
  //  small sidenotes, cards, or whatever.

  $selector-name: ".outdent";

  @if $marginalia == true {
	$selector-name: ".marginalia";
  }

  //  Note: LibSass doesn't like how I'm concatenating the selector below. When
  //  compiling this via Libsass in Codekit, I got an error:
  //  "Invalid CSS after "&-left": expected selector, was '"." + blockquote'"
  
  //  (Lib is deprecated anyway, and this is not a problem in Dart)
  @if $scope-to-class == true {
	$label: "." + #{$label};
  }
  @else {
	$label: -#{$label}
  }


  #{$selector-name}#{$label} {
	//  set up outdents for both left and right
	$medium: map-get($breakpoints, 'medium');
	$large: map-get($breakpoints, 'large');

	@media screen and (min-width: #{$medium}) and (max-width: #{$large}) {
//	@include breakpoint($below-this-is-mobile) {
	
	//	I capped the styles at the large screen size because the default
	//	collapse-to width of 50% was overriding the width that the element
	//	should be at a larger screen size. (The blockquote should be 60% wide
	//	at large, but that style was just applied to .blockquote, whereas the
	//	50% width style was applied to .blockquote.outdent. It was more specific,
	//	so it was overriding the large-screen width.)
	
	  &.place-left {
		  --placement: left;
		}
		&.place-right {
		  --placement: right;
		}

  	  width: $collapse-to;
		  float: var(--placement);
		

	}

	//  The default point of collapse happens at the 'md' breakpoint.
	//  This means that at the medium breakpoint, the width of the item
	//  becomes 50% (or whatever's in $collapse-to), rather than what was specified.

	@include breakpoint(#{$point-of-collapse}) {
		// have to redeclare since the earlier float statement only applies up to
		//	the large screen size
	  float: var(--placement);

	  //  So here's how the outdentation works.

	  //  This is the amount the item will be outdented.
	  --outdent--distance: #{$distance};
	  
	  //  Thing is: for marginalia, the item will be right up against the
	  //  edge of the story content. In order to add more space between the
	  //  item and the content edge, the item needs to be outdented X distance
	  //  more than its width (if the item is 24rem wide, the outdent distance
	  //  would be 26rem).
	  
	  //  I've set this extra space up as a CSS variable to make things easier.
	  //  No need to call it when running the mixin, you can add it to modules as needed.
	  
	  --outdent--distance-adjusted: calc(var(--outdent--distance) + var(--side-space, 0rem));


	  // This is the width of the space - I'm calling it "gutter", to distinguish
	  // from CSS margins - on both sides of the content column.

	  --gutter-width: calc((100vw - var(--standard-content-width)) / 2);

	  //  It's pretty simple: we get it by subtracting the width of the content
	  //  column (let's say it's 50rem wide) from the width of the window, and then
	  //  dividing it by two. That's the amount of empty space on both sides of
	  //  the article.

	  // If we set margin-left to calc(-1 * the gutter space), the item would be fixed to the
	  // left edge of the window, and the content would flow around it as the
	  // window gets narrower. But we want the item to be embedded in the
	  // main content section, just slightly outdented into the gutter area.

	  //  Let's say we want to outdent an item by 10%; that is, have the item
	  //  positioned 10% into the left gutter of the story/article.

	  // So what's smaller, 10% of the floated module, or that gutter area?

	  // min() is basically a very compact if-else statement.

	  // - If "10%" is smaller than the width of the left gutter: use that number.
	  // 	So the item is margin-left: -10%. For wider windows, the item will
	  // 	be indented -10%. That's the appearance we want.

	  // - But if --gutter-width is smaller than 10% - that is, if the left gutter
	  //  area is narrower than 10% of the item's width - outdent the item
	  //  according to the gutter width instead. That means that the
	  //  margin-left switches from -10% of the item width, which might overshoot
	  //  the left edge, to whatever the remaining width is in the gutter.
	  --final-outdent-distance: min(
		var(--outdent--distance-adjusted),
		var(--gutter-width)
	  );

	  //  Now if we just left it at that - if we just set margin-left to negative
	  //  whatever value min() returns above - what would happen is that:

	  // 		- on wide windows, everything works as normal
	  // 		- but on narrow windows:
	  // 			a. calc((100vw - 50rem) / 2) is going to resolve to a *negative* number, since 50rem is now
	  // 				*bigger* than 100vw
	  // 			b. that negative number is then multiplied by -1, so the left
	  //  margin now works out to a *positive* number. So as you make the window
	  //  narrower, the aligned item is going to have an increasingly
	  //  large left margin. It's not going to be neatly pinned to the left edge of
	  //  the window the way we want.

	  // 		So we need another if-else statement, basically. What's smaller, the calculated left margin or 0?
	  --margin-space: min(calc(-1 * var(--final-outdent-distance)), 0rem);

	  padding: var(--item-padding, 0%);

	  //  since marginalia items are entirely outside of the content column,
	  //  their width must be the same as the outdent distance.
	  @if $marginalia == true {
		width: var(--outdent--distance);
	  }

	  &.place-left {
		--placement: left;
//		margin-left: var(--margin-space);
//		margin-right: var(--side-space, 0rem);

		margin: var(--y-space, 2rem) var(--side-space, 2rem) var(--y-space, 2rem) var(--margin-space);

		//	This ensures that the element appears above the fixed-position table of
		//	contents, if such a thing exists		
		z-index: 10;
		position: relative;

		
	  }
	  &.place-right {
		--placement: right;
//		margin-right: var(--margin-space);
//		margin-left: var(--side-space, 0rem);

		margin: var(--y-space, 2rem) var(--margin-space) var(--y-space, 2rem) var(--side-space, 2rem);

		//	This ensures that the element appears above the fixed-position table of
		//	contents, if such a thing exists		
		z-index: 10;
		position: relative;


	  }
	}
  }
}


